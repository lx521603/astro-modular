---
import type { Post } from '@/types';
import { processImagesForLightbox, getOptimizedFormat } from '@/utils/images';
import { siteConfig } from '@/config';
import { formatDate, formatDateMobile, getReadingTimeMobile } from '@/utils/markdown';
import ImageGallery from './ImageGallery.astro';
import TableOfContents from './TableOfContents.astro';
import Button from './Button.astro';
import ImageWrapper from './ImageWrapper.astro';

export interface Props {
  post: Post & {
    Content: any;
    toc: any[];
    readingTime?: any;
    wordCount?: number;
  };
}

const { post } = Astro.props;
const { Content, toc, readingTime, wordCount } = post;

// 处理图片字段中的 Obsidian 方括号语法
const processedImage = (() => {
  if (!post.data.image) return post.data.image;

  // 处理图片是数组的情况（未加引号的 YAML 语法）
  let imageValue = post.data.image;
  if (Array.isArray(post.data.image)) {
    // 如果是数组，取第一个元素
    imageValue = post.data.image[0];
  }

  // 在调用字符串方法之前确保 imageValue 是字符串
  if (typeof imageValue !== 'string') {
    console.warn('PostContent: imageValue 不是字符串:', imageValue);
    return imageValue;
  }

  // 检查是否是 Obsidian 双括号语法
  if (imageValue.startsWith('[[') && imageValue.endsWith(']]')) {
    // 提取双括号内的内容
    return imageValue.slice(2, -2);
  }

  return imageValue;
})();
---

<div class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8">
  <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">
    <!-- 主要内容 -->
    <div class="lg:col-span-8 xl:col-span-9">
      <!-- 文章页眉 -->
      <header class="mb-8">
        <h1 class="text-3xl sm:text-4xl font-bold text-primary-900 dark:text-primary-50 mb-6 leading-tight">
          {post.data.title}
        </h1>

        <div class="flex flex-wrap items-center gap-x-4 gap-y-2 text-sm text-primary-600 dark:text-primary-300 mb-6">
          <time datetime={post.data.date.toISOString()} class="font-medium">
            <span class="hidden sm:inline">
              {formatDate(post.data.date)}
            </span>
            <span class="sm:hidden">
              {formatDateMobile(post.data.date)}
            </span>
          </time>

          {siteConfig.postOptions.readingTime && readingTime && (
            <>
              <span class="hidden sm:inline">•</span>
              <span class="sm:hidden">•</span>
              <span>
                <span class="hidden sm:inline">{readingTime.text}</span>
                <span class="sm:hidden">{getReadingTimeMobile(readingTime)}</span>
              </span>
            </>
          )}

          {siteConfig.postOptions.wordCount && wordCount && (
            <>
              <span class="hidden sm:inline">•</span>
              <span class="sm:hidden">•</span>
              <span class="min-w-0">
                <span class="hidden sm:inline">{wordCount.toLocaleString()} 字</span>
                <span class="sm:hidden">{wordCount.toLocaleString()} 字</span>
              </span>
            </>
          )}
        </div>

        {post.data.tags && post.data.tags.length > 0 && siteConfig.postOptions.tags && (
          <div class="flex flex-wrap gap-2 mb-8">
            {post.data.tags.map(tag => (
              <a
                href={`/posts?tag=${encodeURIComponent(tag)}`}
                class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-primary-100 dark:bg-primary-800 text-primary-800 dark:text-primary-200 hover:bg-primary-200 dark:hover:bg-primary-700 transition-colors"
              >
                #{tag}
              </a>
            ))}
          </div>
        )}

        {processedImage && (
          <div class="aspect-video overflow-hidden rounded-xl mb-8">
            <ImageWrapper
              src={(() => {
                // 通过移除 Obsidian 括号来清理图片路径
                let cleanImagePath = processedImage;
                if (!cleanImagePath || typeof cleanImagePath !== 'string') return '';
                if (cleanImagePath.startsWith('[[') && cleanImagePath.endsWith(']]')) {
                  cleanImagePath = cleanImagePath.slice(2, -2);
                }
                
                // 处理外部 URL
                if (cleanImagePath.startsWith('http')) {
                  return cleanImagePath;
                }
                
                // 检测基于文件夹与基于文件：如果图片路径以 'attachments/' 开头，
                // 则是单文件文章（共享附件文件夹）
                const isFileBased = cleanImagePath.startsWith('attachments/');
                
                if (isFileBased) {
                  // 单文件文章 - 移除 attachments/ 前缀
                  cleanImagePath = cleanImagePath.replace('attachments/', '');
                } else {
                  // 基于文件夹的文章 - 同步脚本将图片复制到文章文件夹根目录
                  // 如果存在则移除 'images/' 或 'attachments/' 前缀（同步脚本会移除它们）
                  if (cleanImagePath.startsWith('images/') || cleanImagePath.startsWith('attachments/')) {
                    cleanImagePath = cleanImagePath.replace(/^(images|attachments)\//, '');
                  }
                }
                
                // 如果适用则转换为 WebP（sync-images.js 会创建 WebP 版本）
                return getOptimizedFormat(cleanImagePath);
              })()}
              basePath={(() => {
                // 1. 外部 URL - 不需要 basePath
                if (typeof processedImage === 'string' && processedImage.startsWith('http')) {
                  return '';
                }

                // 2. 清理图片路径以检查 attachments/ 前缀
                let cleanImagePath = processedImage;
                if (typeof cleanImagePath === 'string' && cleanImagePath.startsWith('[[') && cleanImagePath.endsWith(']]')) {
                  cleanImagePath = cleanImagePath.slice(2, -2);
                }

                // 3. 检测基于文件夹与基于文件：如果图片路径以 'attachments/' 开头，
                // 则是单文件文章（共享附件文件夹）
                if (typeof cleanImagePath === 'string' && cleanImagePath.startsWith('attachments/')) {
                  // 图片在附件文件夹中的单文件文章
                  return '/posts/attachments/';
                }

                // 4. 基于文件夹的文章 - 同步脚本将图片复制到文章文件夹根目录
                // 安全检查：在使用 post.id 之前确保它存在
                if (post.id) {
                  return `/posts/${post.id}/`;
                }

                // 如果 post.id 未定义，回退到附件目录
                return '/posts/attachments/';
              })()}
              alt={post.data.imageAlt || `文章中的图片: ${post.data.title}`}
              class="w-full h-full"
              width={1200}
              height={675}
              format={typeof processedImage === 'string' && processedImage.endsWith('.svg') ? undefined : "webp"}
              quality={90}
              densities={[1, 2]}
              loading="eager"
              fetchpriority="high"
            />
          </div>
        )}
      </header>

      <!-- 文章内容 -->
      <div class="prose dark:prose-dark max-w-none table-responsive">
        <Content />
      </div>
    </div>

    <!-- 侧边栏 -->
    <div class="lg:col-span-4 xl:col-span-3">
      <div class="sticky top-24 space-y-6">
        <!-- 目录 -->
        {siteConfig.tableOfContents.enabled && toc && toc.length > 0 && (
          <TableOfContents headings={toc} />
        )}

        <!-- 文章元信息 -->
        <div class="p-6 bg-primary-50 dark:bg-primary-800/50 rounded-xl">
          <h3 class="font-semibold text-primary-900 dark:text-primary-50 mb-4">
            文章信息
          </h3>
          <div class="space-y-3 text-sm">
            <div class="flex justify-between">
              <span class="text-primary-600 dark:text-primary-300">发布时间</span>
              <span class="text-primary-900 dark:text-primary-50">
                {formatDate(post.data.date)}
              </span>
            </div>

            {readingTime && (
              <div class="flex justify-between">
                <span class="text-primary-600 dark:text-primary-300">阅读时间</span>
                <span class="text-primary-900 dark:text-primary-50">{readingTime.text}</span>
              </div>
            )}

            {wordCount && (
              <div class="flex justify-between">
                <span class="text-primary-600 dark:text-primary-300">字数统计</span>
                <span class="text-primary-900 dark:text-primary-50">{wordCount.toLocaleString()}</span>
              </div>
            )}

            {post.data.targetKeyword && (
              <div class="flex justify-between">
                <span class="text-primary-600 dark:text-primary-300">目标关键词</span>
                <span class="text-primary-900 dark:text-primary-50 text-right">{post.data.targetKeyword}</span>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  // 将表格包装在响应式容器中，以获得更好的移动端体验
  document.addEventListener('DOMContentLoaded', function() {
    const tables = document.querySelectorAll('.prose table');
    tables.forEach(table => {
      if (table.parentElement && !table.parentElement.classList.contains('table-wrapper')) {
        const wrapper = document.createElement('div');
        wrapper.className = 'table-wrapper';

        if (table.parentNode) {
          table.parentNode.insertBefore(wrapper, table);
        }
        wrapper.appendChild(table);

        // 重置表格边距，因为包装器会处理它
        (table as HTMLElement).style.margin = '0';
      }
    });
  });

  // 初始化锚点链接检测
  document.addEventListener('DOMContentLoaded', () => {
    // 锚点链接由下面的点击事件监听器自动处理
  });

  // 处理带平滑滚动的标题链接（在 DOMContentLoaded 外部）
  document.addEventListener('click', (e) => {
    // 检查点击的元素是否是锚点链接
    const target = e.target as HTMLElement;
    if (target && target.tagName === 'A' && target.classList.contains('anchor-link')) {
      const href = target.getAttribute('href');

      if (href && href.startsWith('#') && href.length > 1) {
        const targetElement = document.querySelector(href);

        if (targetElement) {
          e.preventDefault();

          // 更新 URL
          history.pushState(null, '', href);

          // 自定义平滑滚动实现
          const targetPosition = (targetElement as HTMLElement).offsetTop - 100; // 考虑页眉高度
          const startPosition = window.pageYOffset;
          const distance = targetPosition - startPosition;
          const duration = 800; // 800ms 持续时间
          let start: number | null = null;

          function step(timestamp: number) {
            if (!start) start = timestamp;
            const progress = timestamp - start;
            const percentage = Math.min(progress / duration, 1);

            // 缓动函数（ease-in-out）
            const easeInOut = percentage < 0.5
              ? 2 * percentage * percentage
              : 1 - Math.pow(-2 * percentage + 2, 2) / 2;

            window.scrollTo(0, startPosition + distance * easeInOut);

            if (progress < duration) {
              requestAnimationFrame(step);
            }
          }

          requestAnimationFrame(step);
        }
      }
    }
  });
</script>